The second four registers (ESP, EBP, ESI, and EDI) are also general-
purpose registers, but they are sometimes known as pointers and indexes.
These stand for Stack Pointer, Base Pointer, Source Index, and Destination Index,

they store 32-bit
addresses, which essentially point to that location in memory. These registers
are fairly important to program execution and memory management; we will
discuss them more later. The last two registers are also technically pointers,
24
0x200which are commonly used to point to the source and destination when data
needs to be read from or written to.

the disassembly syntax
can be set to Intel by simply typing set disassembly intel or set dis intel ,
for short. You can configure this setting to run every time GDB starts up by
putting the command in the file .gdbinit in your home directory.

The -g flag can be used by the GCC compiler to include extra debugging
information, which will give GDB access to the source code. command => list

b A single byte
h A halfword, which is two bytes in size
w A word, which is four bytes in size
g A giant, which is eight bytes in size

This is because on the x86 processor values are stored in little-endian
byte order, which means the least significant byte is stored first. For example,
if four bytes are to be interpreted as a single value, the bytes must be used
in reverse order. The GDB debugger is smart enough to know how values
are stored, so when a word or halfword is examined, the bytes must be
reversed to display the correct values in hexadecimal. Revisiting these
values displayed both as hexadecimal and unsigned decimals might help
clear up any confusion.


The memory at this location can be
examined several different ways
(gdb) i r ebp
(gdb) x/4xb $ebp - 4
(gdb) x/4xb 0xbffff804

(gdb) print $ebp - 4
$1 = (void *) 0xbffff804

(gdb) x/4xb $1

(gdb) x/xw $1


(gdb) x/6cb 0x8048484
0x8048484:
72 'H' 101 'e' 108 'l' 108 'l' 111 'o' 32 ' '

The null byte

str_a[14] = 0;
0x200at the end is used as a delimiter character to tell any function that is dealing
with the string to stop operations right there. The remaining extra bytes are
just garbage and will be ignored. If a null byte is inserted in the fifth element
of the character array, only the characters Hello would be printed by the
printf() function




A 32-bit
unsigned integer can contain values from 0 (all binary 0s) to 4,294,967,295
(all binary 1s). A 32-bit signed integer is still just 32 bits, which means it can
P rog ra m min g
41only be in one of 2 32 possible bit combinations. This allows 32-bit signed
integers to range from −2,147,483,648 to 2,147,483,647. Essentially, one of
the bits is a flag marking the value positive or negative. Positively signed values
look the same as unsigned values, but negative numbers are stored differently
using a method called two’s complement. Two’s complement represents neg-
ative numbers in a form suited for binary adders—when a negative value in
two’s complement is added to a positive number of the same magnitude, the
result will be 0. This is done by first writing the positive number in binary, then
inverting all the bits, and finally adding 1. It sounds strange, but it works and
allows negative numbers to be added in combination with positive numbers
using simple binary adders.

reader@hacking:~/booksrc $ pcalc 0y01001001
73
0x49
0y1001001
reader@hacking:~/booksrc $ pcalc 0y10110110 + 1
183
0xb7
0y10110111
reader@hacking:~/booksrc $ pcalc 0y01001001 + 0y10110111
256
0x100
0y100000000

First, the binary value 01001001 is shown to be positive 73. Then all the
bits are flipped, and 1 is added to result in the two’s complement representa-
tion for negative 73, 10110111. When these two values are added together,
the result of the original 8 bits is 0. The program pcalc shows the value 256
because it’s not aware that we’re only dealing with 8-bit values. In a binary
adder, that carry bit would just be thrown away because the end of the vari-
able’s memory would have been reached. 
