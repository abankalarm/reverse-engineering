The second four registers (ESP, EBP, ESI, and EDI) are also general-
purpose registers, but they are sometimes known as pointers and indexes.
These stand for Stack Pointer, Base Pointer, Source Index, and Destination Index,

they store 32-bit
addresses, which essentially point to that location in memory. These registers
are fairly important to program execution and memory management; we will
discuss them more later. The last two registers are also technically pointers,
24
0x200which are commonly used to point to the source and destination when data
needs to be read from or written to.

the disassembly syntax
can be set to Intel by simply typing set disassembly intel or set dis intel ,
for short. You can configure this setting to run every time GDB starts up by
putting the command in the file .gdbinit in your home directory.

The -g flag can be used by the GCC compiler to include extra debugging
information, which will give GDB access to the source code. command => list

b A single byte
h A halfword, which is two bytes in size
w A word, which is four bytes in size
g A giant, which is eight bytes in size

This is because on the x86 processor values are stored in little-endian
byte order, which means the least significant byte is stored first. For example,
if four bytes are to be interpreted as a single value, the bytes must be used
in reverse order. The GDB debugger is smart enough to know how values
are stored, so when a word or halfword is examined, the bytes must be
reversed to display the correct values in hexadecimal. Revisiting these
values displayed both as hexadecimal and unsigned decimals might help
clear up any confusion.


The memory at this location can be
examined several different ways
(gdb) i r ebp
(gdb) x/4xb $ebp - 4
(gdb) x/4xb 0xbffff804

(gdb) print $ebp - 4
$1 = (void *) 0xbffff804

(gdb) x/4xb $1

(gdb) x/xw $1


(gdb) x/6cb 0x8048484
0x8048484:
72 'H' 101 'e' 108 'l' 108 'l' 111 'o' 32 ' '

The null byte

str_a[14] = 0;
0x200at the end is used as a delimiter character to tell any function that is dealing
with the string to stop operations right there. The remaining extra bytes are
just garbage and will be ignored. If a null byte is inserted in the fifth element
of the character array, only the characters Hello would be printed by the
printf() function




A 32-bit
unsigned integer can contain values from 0 (all binary 0s) to 4,294,967,295
(all binary 1s). A 32-bit signed integer is still just 32 bits, which means it can
P rog ra m min g
41only be in one of 2 32 possible bit combinations. This allows 32-bit signed
integers to range from −2,147,483,648 to 2,147,483,647. Essentially, one of
the bits is a flag marking the value positive or negative. Positively signed values
look the same as unsigned values, but negative numbers are stored differently
using a method called two’s complement. Two’s complement represents neg-
ative numbers in a form suited for binary adders—when a negative value in
two’s complement is added to a positive number of the same magnitude, the
result will be 0. This is done by first writing the positive number in binary, then
inverting all the bits, and finally adding 1. It sounds strange, but it works and
allows negative numbers to be added in combination with positive numbers
using simple binary adders.

reader@hacking:~/booksrc $ pcalc 0y01001001
73
0x49
0y1001001
reader@hacking:~/booksrc $ pcalc 0y10110110 + 1
183
0xb7
0y10110111
reader@hacking:~/booksrc $ pcalc 0y01001001 + 0y10110111
256
0x100
0y100000000

First, the binary value 01001001 is shown to be positive 73. Then all the
bits are flipped, and 1 is added to result in the two’s complement representa-
tion for negative 73, 10110111. When these two values are added together,
the result of the original 8 bits is 0. The program pcalc shows the value 256
because it’s not aware that we’re only dealing with 8-bit values. In a binary
adder, that carry bit would just be thrown away because the end of the vari-
able’s memory would have been reached. 

Parameter Output Type
%d Decimal
%u Unsigned decimal
%x Hexadecimal

Parameter Output Type
%s String
%n Number of bytes written so far

The %s format parameter expects to be given a memory address; it prints
the data at that memory address until a null byte is encountered. The %n
format parameter is unique in that it actually writes data. It also expects to be
given a memory address, and it writes the number of bytes that have been
written so far into that memory address.



Typecasting is simply a way to temporarily change a variable’s data type, despite
how it was originally defined. When a variable is typecast into a different
type, the compiler is basically told to treat that variable as if it were the
new data type, but only for that operation. The syntax for typecasting is
as follows:
(typecast_data_type) variable
c = a / b;
d = (float) a / (float) b;
// Divide using integers.
// Divide integers typecast as floats.

The pointer_types3.c program can be modified to use a single void
pointer by typecasting it to the proper type each time it’s used. The compiler
knows that a void pointer is typeless, so any type of pointer can be stored in a
void pointer without typecasting. This also means a void pointer must always
be typecast when dereferencing it, however. These differences can be seen in
pointer_types4.c, which uses a void pointer.
void *void_pointer;
void_pointer = (void *) char_array;


#include <stdio.h>
int main() {
int i;
char char_array[5] = {'a', 'b', 'c', 'd', 'e'};
int int_array[5] = {1, 2, 3, 4, 5};
void *void_pointer;
void_pointer = (void *) char_array;
for(i=0; i < 5; i++) { // Iterate through the int array with the int_pointer.
printf("[char pointer] points to %p, which contains the char '%c'\n",
void_pointer, *((char *) void_pointer));
void_pointer = (void *) ((char *) void_pointer + 1);
}
void_pointer = (void *) int_array;
for(i=0; i < 5; i++) { // Iterate through the int array with the int_pointer.
printf("[integer pointer] points to %p, which contains the integer %d\n",
void_pointer, *((int *) void_pointer));
void_pointer = (void *) ((int *) void_pointer + 1);
}
}



A compiled program’s memory is divided into five segments: text, data, bss,
heap, and stack. Each segment represents a special portion of memory that is
set aside for a certain purpose.
The text segment is also sometimes called the code segment. This is where
the assembled machine language instructions of the program are located.
The execution of instructions in this segment is nonlinear, thanks to the
aforementioned high-level control structures and functions, which compile
into branch, jump, and call instructions in assembly language. As a program
executes, the EIP is set to the first instruction in the text segment. The
processor then follows an execution loop that does the following:
1. Reads the instruction that EIP is pointing to
2. Adds the byte length of the instruction to EIP
3. Executes the instruction that was read in step 1
4. Goes back to step 1

In C, as in other compiled languages, the compiled code goes into the text
segment, while the variables reside in the remaining segments. Exactly which
memory segment a variable will be stored in depends on how the variable is
defined. Variables that are defined outside of any functions are considered
to be global. The static keyword can also be prepended to any variable
declaration to make the variable static. If static or global variables are initial-
ized with data, they are stored in the data memory segment; otherwise, these
variables are put in the bss memory segment. Memory on the heap memory
segment must first be allocated using a memory allocation function called
malloc() . Usually, pointers are used to reference memory on the heap.
Finally, the remaining function variables are stored in the stack memory
segment. Since the stack can contain many different stack frames, stack
variables can maintain uniqueness within different functional contexts.
The memory_segments.c program will help explain these concepts in C.-
